<!DOCTYPE html>
<html>
<head>
  <title>Creature Viewer</title>
  <style>
    canvas {
      image-rendering: pixelated;
      background: #333;
      display: block;
      margin: 0 auto;
    }
    #frame-counter {
      position: absolute;
      top: 8px;
      left: 8px;
      color: white;
      font-family: monospace;
      font-size: 14px;
      background: rgba(0, 0, 0, 0.4);
      padding: 4px 8px;
      border-radius: 4px;
    }
    body {
      margin: 0;
      overflow: hidden;
      background: #222;
    }
  </style>
</head>
<body>
  <div id="frame-counter">Frame: 0</div>
  <canvas id="world" width="500" height="500"></canvas>

  <script>
    let CREATURES = {};
    let FOOD = new Set();
    let SPRITES = {};
    let deltaFrames = {};
    let currentFrame = 0;

    let lastRealTime = Date.now();
    let baseSimFrame = 0; // From /getstate
    let lastStateFetchTime = 0;

    const canvas = document.getElementById("world");
    const ctx = canvas.getContext("2d");
    const frameDisplay = document.getElementById("frame-counter");

    function parseDeltaFrame(frameStr) {
        const events = frameStr.match(/(s|m|r|o)\[[^\]]*\]/g) || [];

        for (const e of events) {
            if (e.startsWith("s[")) {
            const [id, x, y, sprite] = e.slice(2, -1).split(',');
            CREATURES[id] = {
                id: +id,
                position: [+x, +y],
                direction: 0,
                sprite_id: +sprite
            };
            } else if (e.startsWith("m[")) {
            const [id, x, y, d] = e.slice(2, -1).split(',');
            if (CREATURES[id]) {
                CREATURES[id].position = [+x, +y];
                CREATURES[id].direction = +d;
            }
            } else if (e.startsWith("r[")) {
            const id = e.slice(2, -1);
            if (CREATURES[id]) {
                delete CREATURES[id];
            }
            } else if (e.startsWith("o[")) {
            const [id, newSprite] = e.slice(2, -1).split(',');
            if (CREATURES[id]) {
                CREATURES[id].sprite_id = +newSprite;
                console.log(`ðŸŽ¨ Updated sprite_id of creature ${id} to ${newSprite}`);
            }
            } else {
            // console.warn(`â“ Unknown delta event: ${e}`);
            }
        }
        }


        

    function parseFoodFrame(newStr, delStr) {
        //console.log("ðŸ”¥ Incoming food strings:", newStr, delStr);

        const addMatches = newStr.match(/\[\d+,\d+\]/g) || [];
        const delMatches = delStr.match(/\[\d+,\d+\]/g) || [];

        for (const f of addMatches) {
            const [x, y] = f.slice(1, -1).split(',').map(Number);
            FOOD.add(`${x},${y}`);
            //console.log(`âœ… Added food at (${x}, ${y})`);
        }

        for (const f of delMatches) {
            const [x, y] = f.slice(1, -1).split(',').map(Number);
            FOOD.delete(`${x},${y}`);
            //console.log(`âŒ Removed food at (${x}, ${y})`);
        }
        }

    function drawFrame() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw food
      ctx.fillStyle = "green";
      for (const pos of FOOD) {
        const [x, y] = pos.split(',').map(Number);
        ctx.beginPath();
        ctx.arc(x, y, 4, 0, 2 * Math.PI);
        ctx.fill();
      }

      // Draw creatures
      for (const c of Object.values(CREATURES)) {
        const angle = c.direction;
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        const layout = SPRITES[c.sprite_id];
        if (!layout || typeof layout !== "string") continue;

        const organs = layout.split("|").filter(Boolean).map(line => {
          const [type, x, y, size] = line.split(",");
          return {
            type,
            x: parseFloat(x),
            y: parseFloat(y),
            size: parseFloat(size),
          };
        });

        const body = organs.find(o => o.type === "body") || { x: 0, y: 0 };
        const body_rx = body.x * cos - body.y * sin;
        const body_ry = body.x * sin + body.y * cos;
        const cx = c.position[0] + body_rx;
        const cy = c.position[1] + body_ry;

        for (const organ of organs) {
          if (organ.type === "body") continue;
          const rx = organ.x * cos - organ.y * sin;
          const ry = organ.x * sin + organ.y * cos;
          const ox = c.position[0] + rx;
          const oy = c.position[1] + ry;

          switch (organ.type) {
            case "spike": ctx.fillStyle = "red"; break;
            case "mouth": ctx.fillStyle = "yellow"; break;
            case "eye": ctx.fillStyle = "white"; break;
            case "flipper": ctx.fillStyle = "orange"; break;
            default: ctx.fillStyle = "#ccc"; break;
          }

          ctx.strokeStyle = "#000";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(cx, cy);
          ctx.lineTo(ox, oy);
          ctx.stroke();

          ctx.beginPath();
          ctx.arc(ox, oy, organ.size * 0.5, 0, 2 * Math.PI);
          ctx.fill();
        }

        ctx.fillStyle = "blue";
        ctx.beginPath();
        ctx.arc(cx, cy, 8, 0, 2 * Math.PI);
        ctx.fill();
      }

      frameDisplay.textContent = `Frame: ${currentFrame}`;
    }

    function playbackTick() {
    const delta = deltaFrames[String(currentFrame)];
    if (delta) {
        //console.log(`ðŸ“¦ Applying delta for frame ${currentFrame}`);

        console.log(delta)

        if (delta.creatures) {
        //console.log(`â†ªï¸ Creatures: ${delta.creatures}`);
        parseDeltaFrame(delta.creatures);  // âœ… correct
        }

        if (delta.new_food !== undefined || delta.deleted_food !== undefined) {
        console.log("ðŸŒ± New food:", JSON.stringify(delta.new_food));
        console.log("ðŸ—‘ï¸ Deleted food:", JSON.stringify(delta.deleted_food));

        parseFoodFrame(delta.new_food || "", delta.deleted_food || "");
        }
    } else {
        //console.log(`â­ï¸ No delta for frame ${currentFrame}`);
    }

    drawFrame();
    currentFrame++;
    }


    async function fetchInitialState() {
        try {
            const res = await fetch("/evolvit/getstate?x=0&y=0");
            const data = await res.json();

            if (data.status === "pending") {
            console.log("â³ Server says: pending");
            return;
            }

            // Reset everything
            CREATURES = {};
            FOOD = new Set();
            deltaFrames = {};

            // Apply snapshot
            for (const c of data.state.creatures) {
            CREATURES[c.id] = {
                id: c.id,
                position: c.position,
                direction: c.direction || 0,
                sprite_id: c.sprite_id
            };
            }

            for (const f of data.state.food) {
            FOOD.add(`${f[0]},${f[1]}`);
            }

            // âœ… Store deltas
            deltaFrames = data.deltas || {};

            // âœ… Redraw immediately
            drawFrame();

            // âœ… THEN update frame
            currentFrame = data.frame + 1;

            lastRealTime = Date.now();
            baseSimFrame = data.frame + 1;
            currentFrame = baseSimFrame;

        } catch (err) {
            console.error("Error fetching state:", err);
        }
        }

    async function fetchSprites() {
      try {
        const res = await fetch("/evolvit/getsprites");
        const spriteList = await res.json();
        SPRITES = {};
        for (const sprite of spriteList) {
          SPRITES[sprite.id] = sprite.layout;
        }
      } catch (err) {
        console.error("Error fetching sprites:", err);
      }
    }

    // Initialize
    fetchInitialState();
    fetchSprites();

    // Run simulation at 30fps
    setInterval(() => {
        const now = Date.now();
        const elapsedMs = now - lastRealTime;

        // How many frames should have passed based on real time
        const targetFrame = baseSimFrame + Math.floor(elapsedMs / (1000 / 30));

        // Apply all deltas up to the current frame
        while (currentFrame < targetFrame) {
            const delta = deltaFrames[currentFrame];
            if (delta) {

                //console.log(delta);
            parseDeltaFrame(delta.creatures || "");
            parseFoodFrame(delta.new_food || "", delta.deleted_food || "");
            }
            currentFrame++;
        }

        drawFrame(); // always draw current state

        // Refresh state if 10s of real time has passed
        if (now - lastStateFetchTime >= 10000) {
            fetchInitialState();
            lastStateFetchTime = now;
        }
        }, 1000 / 30);

    // Refresh sprites every 5s
    setInterval(fetchSprites, 10000);
  </script>
</body>
</html>
